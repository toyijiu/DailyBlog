##简单工厂模式
分离对象的创建和操作
##demo
```cpp
#include<iostream>
#include<string>

using namespace std;

//Operation基类和实现类
class Operation{
		public:
		double numberA,numberB;
		virtual double getResult(){
			return 0;
		}
};

//各实现类暂不考虑溢出问题
class AddOperation:public Operation{
	public:
	double getResult(){
		return numberA + numberB;
	}
};

class SubOperation:public Operation{
	public:
		double getResult(){
			return numberA - numberB;
		}
};

class MulOperation:public Operation{
	public:
		double getResult(){
			return numberA * numberB;
		}
};

class DivOperation:public Operation{
	public:
		double getResult(){
			//暂不考虑除数为0等异常
			return numberA/numberB;
		}
};

//工厂类，提供具体的操作
class Factory{
	public:
		static Operation* getConcOperation(char means){
			switch(means){
				case '+':
					return new AddOperation();
				
				case '-':
					return new SubOperation();
				
				case '*':
					return new MulOperation();
					
				case '/':
					return new DivOperation();
					
				default:
					cout<<"input means wrong,you input "<<means<<endl;
			}
		}
};

int main(){
	//通过工厂来实现多态
	Operation* oper = Factory::getConcOperation('+');
	oper->numberA = 10;
	oper->numberB = 20;
	//实现具体的operation
	cout<<oper->getResult()<<endl;
	system("pause");
	return 0;
}
```
##结果
![这里写图片描述](http://img.blog.csdn.net/20170405233421067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG95aWppdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

##工厂方法
- 具体的操作不是像简单工厂那样通过入参的方式来确定，而是针对性的对应具体的操作建立对应的工厂，缺点是这样的话类就太多了

## demo
```cpp
#include<iostream>
#include<string>

using namespace std;

//Operation基类和实现类
class Operation{
	public:
		double numberA,numberB;
		virtual double getResult(){
			return 0;
		}
};

//各实现类暂不考虑溢出问题
class AddOperation:public Operation{
	public:
	double getResult(){
		return numberA + numberB;
	}
};

class SubOperation:public Operation{
	public:
		double getResult(){
			return numberA - numberB;
		}
};

class MulOperation:public Operation{
	public:
		double getResult(){
			return numberA * numberB;
		}
};

class DivOperation:public Operation{
	public:
		double getResult(){
			//暂不考虑除数为0等异常
			return numberA/numberB;
		}
};

//工厂类，提供具体的操作
class IFactory{
	public:
		virtual Operation* getConcOperation() = 0;
};

class AddFactory:public IFactory{
	public:
	static Operation* getConcOperation(){
		return new AddOperation();
	}
};

class SubFactory:public IFactory{
	public:
	static Operation* getConcOperation(){
		return new SubOperation();
	}
};

class MulFactory:public IFactory{
	public:
	static Operation* getConcOperation(){
		return new MulOperation();
	}
};

class DivFactory:public IFactory{
	public:
	static Operation* getConcOperation(){
		return new DivOperation();
	}
};

int main(){
	//通过工厂来实现多态
	Operation* oper = MulFactory::getConcOperation();
	oper->numberA = 10;
	oper->numberB = 20;
	//实现具体的operation
	cout<<oper->getResult()<<endl;
	system("pause");
	return 0;
}
```
